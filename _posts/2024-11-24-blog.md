---
layout: post
title: 2024 연말 블로그 챌린지 - 2회차
tags: [blog]
author: thdev
cover-img: /images/challenge-2.jpg
---

2024 연말 블로그 챌린지의 2회차 결과를 한 번에 공유합니다.

아래 설명에는 ChatGpt, Gemini, perplexity 사용하여 요약한 내용이라 오류가 있을 수 있음.

## 2회차 챌린지 결과

주요 주제
- kotlin
- Coroutines
- 아키텍처
- 트러블 슈팅
- Compose

## kotlin

### 작성자 skydoves
제목 : A Developer’s Roadmap to Mastering Kotlin Multiplatform

- Kotlin Multiplatform(KMP)은 비즈니스 로직을 여러 플랫폼에서 공유하면서 플랫폼별 UI를 구현할 수 있는 크로스 플랫폼 개발 솔루션입니다.
- KMP는 Android, iOS, Desktop, Web 등 다양한 플랫폼을 지원하며, Compose Multiplatform을 통해 UI 코드도 공유할 수 있습니다.
- KMP 생태계는 Coroutines, Ktor, Room, DataStore 등 다양한 라이브러리를 지원하며, Android 개발자들이 쉽게 접근할 수 있는 장점이 있습니다.

[링크 - A Developer’s Roadmap to Mastering Kotlin Multiplatform(영문)](https://getstream.io/blog/kotlin-multiplatform-roadmap/)

### 작성자 박명범
제목 : [Kotlin/Java] HashSet, HashMap 내부 구현 살펴보기2 — RBT를 사용한 최적화

이 문서는 Kotlin/Java에서 HashSet 및 HashMap의 내부 구현에 관한 것입니다. Red-Black Tree를 사용하여 최적화하는 방법과 연결된 목록과 트리 구조 사이에서 변환하는 조건에 대해 논의합니다. 몇 가지 중요한 요점은 다음과 같습니다.

- HashMap은 버킷의 요소 수가 특정 임계값을 초과할 때 Red-Black Tree를 사용하여 최적화합니다.
- 트리 구조로 변환하는 임계값은 8이고 연결된 목록으로 다시 변환하는 임계값은 6입니다.
- Red-Black Tree 구조는 O(log n)의 시간 복잡도로 효율적인 검색, 삽입 및 삭제 작업을 보장합니다.

[링크 - [Kotlin/Java] HashSet, HashMap 내부 구현 살펴보기2 — RBT를 사용한 최적화](https://medium.com/@mangbaam/kotlin-java-hashset-hashmap-%EB%82%B4%EB%B6%80-%EA%B5%AC%ED%98%84-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B02-rbt%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%B5%9C%EC%A0%81%ED%99%94-cbbcb6d8a288)

### 작성자 정찬호
제목 : Kotlin Value Class With Project Valhalla

이 글은 Java의 HashMap이 데이터 저장 및 관리에서 사용하는 내부 구조와 최적화를 설명합니다. 주요 내용은 다음과 같습니다:

- 해시 충돌 관리: Java 8 이후 HashMap은 초기에는 연결 리스트를 사용하지만, 충돌이 많아지면 시간 복잡도를 개선하기 위해 Red-Black Tree로 전환합니다. 데이터 개수가 다시 적어지면 연결 리스트로 돌아갑니다​.
- 보조 해시 함수: 해시 충돌을 줄이기 위해 기본 해시 함수 외에도 상위 비트를 활용해 추가 연산을 수행하여 해시 값을 개선합니다​.
- 용량 조정: 버킷 크기는 데이터가 증가하면 두 배로 늘어나며, 최적의 메모리 활용을 위해 초기 용량과 로드 팩터를 조정해 설정할 수 있습니다.

[링크 - Kotlin Value Class With Project Valhalla](https://chanho-study.tistory.com/152)

## Coroutines

### 작성자 권태환
제목 : Kotlin Coroutines Flow의 Cold/Hot flow(Stream)의 데이터 흐름(Data flow) 이해해 보기

이 글은 Kotlin의 Flow, StateFlow, 그리고 SharedFlow를 활용해 데이터를 처리하는 방법에 대해 다룹니다. 주요 내용은 다음과 같습니다:

- StateFlow와 SharedFlow 비교: StateFlow는 최신 상태를 유지하는 데 적합하며, 반면 SharedFlow는 순차적 데이터 처리가 필요할 때 더 유용합니다. 각각의 특성과 사용 사례를 코드 예제와 함께 설명합니다.
- 코루틴 기반 데이터 처리: 콜백 데이터를 Flow로 변환하고 수집(collect)하는 방법과 이를 처리할 때 발생할 수 있는 비동기성 문제를 다룹니다. 특히 callbackFlow를 활용한 코드 구조도 소개합니다.
- 효율적인 비동기 처리: UI 블로킹을 방지하고, suspend와 runBlocking의 적절한 사용을 통해 안정적인 데이터 흐름을 보장하는 방법을 제안합니다.

[링크 - Kotlin Coroutines Flow의 Cold/Hot flow(Stream)의 데이터 흐름(Data flow) 이해해 보기](https://thdev.tech/dataflow/2024/11/23/Flow-Data-flow/)


## 아키텍처

### 작성자 이지훈
제목 : [Android / Compose] Circuit rememberRetained, produceRetainedState 함수 분석

이 글은 Jetpack Compose에서 상태 관리를 중심으로 Slack의 Circuit 라이브러리를 사용한 새로운 구조를 소개합니다. 주요 요약은 다음과 같습니다:

- Circuit의 상태 관리: Circuit은 rememberRetained와 produceRetainedState를 활용해 Compose에서 상태를 효율적으로 관리하며, 기존의 ViewModel 기반 상태 관리보다 간결한 코드를 제공합니다.
- UI 및 네비게이션: Circuit은 자체 네비게이션 시스템을 통해 Compose Navigation과 다른 접근 방식을 사용하며, 백스택 관리 및 화면 상태 유지에 강점을 가집니다.
- Compose 친화적인 설계: Circuit의 Presenter 및 State 개념은 선언형 UI 원칙에 맞춰 UI 상태와 이벤트를 효율적으로 연결합니다.

[링크 - [Android / Compose] Circuit rememberRetained, produceRetainedState 함수 분석](https://velog.io/@mraz3068/Circuit-rememberRetained-produceRetainedState-Deep-Dive)


### 작성자 이태희
제목 : [Android] MVI 패턴에 대한 고찰

- MVI 패턴은 UI 상태 관리에서 데이터 흐름을 단방향으로 처리하여 복잡성을 줄이고 유지보수를 용이하게 만듭니다.
- UI 상호작용을 명확히 정의하고 상태를 관리하는 데 유리하며, 복잡한 애플리케이션에 적합합니다.
- MVP, MVVM과 비교할 때, MVI는 UI의 일관성을 높이고 오류를 줄이기 위한 효과적인 방법으로 강조됩니다.

[링크 - [Android] MVI 패턴에 대한 고찰](https://haeti.palms.blog/mvi)


## 트러블 슈팅

### 작성자 류기민
제목 : Content access is protected by token : Sonatype OSSRH 401 배포 문제 해결법

- Sonatype OSSRH의 "401 Content access is protected by token" 오류는 Maven과 같은 도구에서 배포 시 인증 토큰이 없을 때 발생합니다. 이는 보안을 강화하려는 Sonatype의 정책 변경 때문입니다​.
- 문제를 해결하려면 Sonatype 계정으로 로그인하여 사용자 프로필에서 인증 토큰을 생성하고, 이를 Maven의 settings.xml 파일에 추가해야 합니다​.
- 관리자는 필요시 "User Tokens" 기능을 비활성화하여 일반 사용자명과 비밀번호로도 인증할 수 있도록 설정을 변경할 수 있습니다​.

[링크 - Content access is protected by token : Sonatype OSSRH 401 배포 문제 해결법](https://workspace.ryukim.in/sonatype-ossrh-401-content-access-is-protected-by-token/)


## Compose

### 작성자 김수현
제목 : LazyColumn 작동 방식 이해하기

- LazyColumn은 Jetpack Compose에서 큰 리스트를 효율적으로 표시하기 위한 컴포넌트입니다. RecyclerView와 비슷하지만 내부적으로 작동 방식이 다릅니다.
- LazyColumn은 화면에 보이는 뷰만 생성하고 화면 밖으로 사라지는 뷰는 삭제합니다.
- LazyColumn은 Compose의 재구성 메커니즘을 사용하여 뷰 노드를 관리합니다.

[링크 - LazyColumn 작동 방식 이해하기](https://medium.com/@wisemuji/lazycolumn-작동-방식-이해하기-0a5433f31306)


### 작성자 강경완
제목 : Compose 컴포넌트 성능 개선: 람다와 Canvas 활용법

- LazyColumn 최적화: key와 contentType을 활용하여 리스트 항목의 불필요한 recomposition을 방지하고 성능을 극대화하는 방법을 다룹니다​.
- 상태 관리 문제: 무한 루프와 같은 상태 업데이트 문제를 피하기 위해 remember와 runningReduce를 활용하는 방법을 설명합니다​.
- 람다 함수 최적화: 람다 사용 시 발생할 수 있는 불필요한 recomposition을 줄이는 기법을 소개합니다​.

[링크 - Compose 컴포넌트 성능 개선: 람다와 Canvas 활용법](https://medium.com/@lucas.kang/compose-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0-%EB%9E%8C%EB%8B%A4%EC%99%80-canvas-%ED%99%9C%EC%9A%A9%EB%B2%95-db24fe9f3abf)


## Prev

[1회차 정리](https://challenge.thdev.tech/2024-11-11-blog/)

## Next

3회차 2주 후에 만나요